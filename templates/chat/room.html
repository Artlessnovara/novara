{% extends "chat_layout.html" %}

{% block chat_content %}
<div class="conversation-page">
    <div class="conversation-header">
        <a href="#" class="back-btn"><i class="fa-solid fa-arrow-left"></i></a>
        <div class="conversation-info">
            {% if chat_info.avatar_url %}
            <img src="{{ chat_info.avatar_url }}" alt="{{ chat_info.name }}" class="conversation-avatar">
            {% endif %}
            <span class="conversation-name">{{ chat_info.name }}</span>
        </div>
        <div class="header-actions">
            {% if current_user.role in ['admin', 'instructor'] and current_user.can_make_calls %}
                {% if chat_info.room_type == 'private' and chat_info.other_user_id %}
                    {# One-to-one call buttons #}
                    <button id="voice-call-btn" data-callee-id="{{ chat_info.other_user_id }}" class="icon-btn call-btn"><i class="fa-solid fa-phone"></i></button>
                    <button id="video-call-btn" data-callee-id="{{ chat_info.other_user_id }}" class="icon-btn call-btn"><i class="fa-solid fa-video"></i></button>
                {% elif chat_info.room_type != 'private' and chat_info.room_type != 'course' %}
                    {# Group call buttons #}
                    <button id="voice-call-btn" class="icon-btn call-btn"><i class="fa-solid fa-phone"></i></button>
                    <button id="video-call-btn" class="icon-btn call-btn"><i class="fa-solid fa-video"></i></button>
                {% endif %}
            {% endif %}
            <a href="#" class="info-btn"><i class="fa-solid fa-circle-info"></i></a>
        </div>
    </div>

    <div id="join-call-banner" class="join-call-banner hidden">
        <span>A call is in progress.</span>
        <button id="join-call-btn" class="btn btn-sm btn-success">Join</button>
    </div>

    <div class="message-area">
        {% for message in messages %}
        <div class="message-bubble-wrapper {% if message.user_id == current_user_id %}sender{% else %}receiver{% endif %}">
            <div class="message-bubble">
                {% if message.file_path %}
                    {% if message.file_name.lower().endswith(('png', 'jpg', 'jpeg', 'gif', 'webp')) %}
                        <img src="/static/{{ message.file_path }}" alt="{{ message.file_name }}" class="message-image">
                    {% elif message.file_name.lower().endswith(('mp4', 'webm', 'ogg')) and 'video' in message.file_name %}
                        <video src="/static/{{ message.file_path }}" controls class="message-video"></video>
                    {% elif message.file_name.lower().endswith(('.mp3', '.wav', '.webm', '.ogg')) %}
                        <audio src="/static/{{ message.file_path }}" controls class="message-audio"></audio>
                    {% else %}
                        <a href="/static/{{ message.file_path }}" class="message-file" download>
                            <i class="fa-solid fa-file-arrow-down"></i> {{ message.file_name }}
                        </a>
                    {% endif %}
                {% else %}
                    {% set content_data = message.content|fromjson(default=none) %}
                    {% if content_data and content_data.type == 'contact' %}
                        <div class="contact-card">
                            <img src="{{ url_for('static', filename='profile_pics/' + content_data.profile_pic) }}" alt="{{ content_data.name }}">
                            <div class="contact-card-info">
                                <strong>{{ content_data.name }}</strong>
                                <a href="{{ url_for('main.view_user', user_id=content_data.user_id) }}">View Profile</a>
                            </div>
                        </div>
                    {% elif content_data and content_data.type == 'location' %}
                        <div class="location-card">
                            <a href="https://www.openstreetmap.org/?mlat={{ content_data.latitude }}&mlon={{ content_data.longitude }}#map=15/{{ content_data.latitude }}/{{ content_data.longitude }}" target="_blank">
                                <i class="fa-solid fa-map-location-dot"></i>
                                <span>View Location</span>
                            </a>
                        </div>
                    {% else %}
                        <p class="message-content">{{ message.content }}</p>
                    {% endif %}
                {% endif %}
                <span class="message-timestamp">{{ message.timestamp.strftime('%I:%M %p') }}</span>
            </div>
        </div>
        {% endfor %}
    </div>

    <div id="media-menu" class="media-menu hidden">
        <div class="media-menu-row">
            <button class="media-option-btn" id="media-camera-btn"><i class="fa-solid fa-camera"></i><span>Camera</span></button>
            <button class="media-option-btn" id="media-gallery-btn"><i class="fa-solid fa-images"></i><span>Gallery</span></button>
            <button class="media-option-btn" id="media-document-btn"><i class="fa-solid fa-file-lines"></i><span>Document</span></button>
        </div>
        <div class="media-menu-row">
            <button class="media-option-btn" id="media-voice-btn"><i class="fa-solid fa-microphone"></i><span>Voice Note</span></button>
            <button class="media-option-btn" id="media-contact-btn"><i class="fa-solid fa-user"></i><span>Contact</span></button>
            <button class="media-option-btn" id="media-location-btn"><i class="fa-solid fa-location-dot"></i><span>Location</span></button>
        </div>
        <div class="media-menu-row">
             <button class="media-option-btn" id="create-poll-btn"><i class="fa-solid fa-chart-simple"></i><span>Poll</span></button>
        </div>
    </div>

    <div class="message-input-bar">
        <emoji-picker class="light hidden"></emoji-picker>
        <button class="icon-btn emoji-btn"><i class="fa-regular fa-face-smile"></i></button>
        <button class="icon-btn media-btn"><i class="fa-solid fa-paperclip"></i></button>
        <textarea class="message-input" placeholder="Type a message" rows="1"></textarea>
        <button class="icon-btn send-btn"><i class="fa-solid fa-paper-plane"></i></button>
    </div>
</div>

<!-- Camera Modal -->
<div id="camera-modal" class="camera-modal hidden">
    <div class="camera-modal-content">
        <video id="camera-preview" autoplay playsinline></video>
        <div class="camera-controls">
            <button id="capture-photo-btn" class="camera-control-btn"><i class="fa-solid fa-camera"></i></button>
            <button id="record-video-btn" class="camera-control-btn"><i class="fa-solid fa-video"></i></button>
            <button id="close-camera-btn" class="camera-control-btn close-btn"><i class="fa-solid fa-xmark"></i></button>
        </div>
    </div>
</div>

<!-- Voice Recorder Bar -->
<div id="voice-recorder-bar" class="message-input-bar hidden">
    <i class="fa-solid fa-trash-can icon-btn" id="cancel-voice-btn"></i>
    <div class="voice-recording-info">
        <i class="fa-solid fa-microphone-lines recording-indicator"></i>
        <span id="voice-timer">00:00</span>
    </div>
    <button class="icon-btn send-btn" id="send-voice-btn"><i class="fa-solid fa-paper-plane"></i></button>
</div>

<!-- Call UI Elements -->
<div id="incoming-call-container" class="call-container hidden">
    <div class="incoming-call-box">
        <img id="incoming-caller-avatar" src="" alt="Caller" class="caller-avatar">
        <h3 id="incoming-caller-name"></h3>
        <p id="incoming-call-type"></p>
        <div class="call-actions">
            <button id="decline-call-btn" class="call-action-btn decline"><i class="fa-solid fa-phone-slash"></i></button>
            <button id="accept-call-btn" class="call-action-btn accept"><i class="fa-solid fa-phone"></i></button>
        </div>
    </div>
</div>

<div id="active-call-container" class="call-container hidden">
    <div id="voice-call-avatar-container" class="hidden">
        <img id="active-call-avatar" src="" class="caller-avatar" alt="Active Call Avatar">
    </div>
    <div id="remote-videos-container">
        <!-- Remote videos will be added here dynamically -->
    </div>
    <video id="local-video" class="call-video" autoplay playsinline muted></video>
    <div class="active-call-ui">
        <div class="peer-info">
            <h3 id="active-caller-name"></h3>
            <p id="active-call-timer">00:00</p>
        </div>
        <div class="call-controls">
            <button id="mute-mic-btn" class="call-control-btn"><i class="fa-solid fa-microphone"></i></button>
            <button id="toggle-camera-btn" class="call-control-btn"><i class="fa-solid fa-video"></i></button>
            <button id="end-active-call-btn" class="call-control-btn end-call"><i class="fa-solid fa-phone-slash"></i></button>
        </div>
    </div>
</div>

<!-- Contact Share Modal -->
<div id="contact-share-modal" class="camera-modal hidden">
    <div class="contact-share-content">
        <h3>Share a contact</h3>
        <div id="contact-list" class="contact-list">
            <!-- Contacts will be populated here by JS -->
        </div>
        <button id="close-contact-modal-btn" class="btn btn-secondary mt-3">Cancel</button>
    </div>
</div>


<style>
    .voice-recording-info {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-grow: 1;
        justify-content: center;
    }
    .recording-indicator {
        color: #d9534f;
        animation: pulse-red 1.5s infinite;
    }
    @keyframes pulse-red {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }

    .conversation-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px;
        background-color: #f0f2f5;
        border-bottom: 1px solid #ddd;
    }
    .header-actions {
        display: flex;
        align-items: center;
        gap: 16px;
    }

    .camera-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }
    .camera-modal.hidden {
        display: none;
    }
    .camera-modal-content {
        background-color: #333;
        padding: 15px;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    #camera-preview {
        width: 100%;
        max-width: 500px;
        border-radius: 8px;
        margin-bottom: 15px;
    }
    .camera-controls {
        display: flex;
        gap: 20px;
    }
    .camera-control-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 2px solid white;
        background-color: rgba(0,0,0,0.5);
        color: white;
        font-size: 20px;
        cursor: pointer;
    }
    .camera-control-btn.recording {
        background-color: red;
    }
    .camera-control-btn.close-btn {
        background-color: #555;
    }

    .media-menu {
        position: absolute;
        bottom: 70px; /* Adjust based on input bar height */
        left: 10px;
        right: 10px;
        background-color: #f0f0f0;
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        transform: translateY(100%);
        opacity: 0;
        z-index: 1000;
    }
    .media-menu.hidden {
        transform: translateY(100%);
        opacity: 0;
        pointer-events: none;
    }
    .media-menu:not(.hidden) {
        transform: translateY(0);
        opacity: 1;
    }
    .media-menu-row {
        display: flex;
        justify-content: space-around;
        margin-bottom: 15px;
    }
    .media-menu-row:last-child {
        margin-bottom: 0;
    }
    .media-option-btn {
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 12px;
        color: #333;
    }
    .media-option-btn i {
        font-size: 24px;
        margin-bottom: 5px;
        width: 50px;
        height: 50px;
        line-height: 50px;
        border-radius: 50%;
        background-color: #fff;
        color: #007bff;
        text-align: center;
    }
    .message-image,
    .message-video {
        max-width: 100%;
        border-radius: 8px;
        margin-bottom: 5px;
    }
    .message-audio {
        width: 100%;
        max-width: 300px;
    }
    .message-file {
        display: inline-block;
        padding: 10px;
        background-color: rgba(0,0,0,0.1);
        border-radius: 8px;
        text-decoration: none;
        color: inherit;
    }
    .poll-container {
        width: 100%;
    }
    .poll-question {
        font-weight: bold;
        margin-bottom: 10px;
    }
    .poll-option {
        background-color: #f0f2f5;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 8px 12px;
        margin-bottom: 5px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background-color 0.2s;
    }
    .poll-option:hover {
        background-color: #e4e6eb;
    }
    .receiver .poll-option {
        background-color: #ffffff;
    }
    .receiver .poll-option:hover {
        background-color: #f7f7f7;
    }
    .poll-option-text {
        flex-grow: 1;
    }
    .poll-option-votes {
        font-size: 0.8em;
        color: #65676b;
        margin-left: 10px;
        z-index: 2; /* Ensure text is above progress bar */
    }
    .poll-option {
        position: relative; /* Needed for progress bar positioning */
        overflow: hidden;
    }
    .poll-option-progress {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background-color: #d2e6ff;
        z-index: 1;
        transition: width 0.3s ease;
        opacity: 0.7;
    }
    .receiver .poll-option-progress {
        background-color: #cceeff;
    }

    /* --- Call UI Styles --- */
    .call-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        z-index: 3000;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }
    .call-container.hidden {
        display: none;
    }
    .incoming-call-box {
        text-align: center;
        color: white;
    }
    .caller-avatar {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 3px solid white;
        margin-bottom: 20px;
    }
    .call-actions {
        margin-top: 30px;
        display: flex;
        gap: 40px;
    }
    .call-action-btn {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: none;
        color: white;
        font-size: 30px;
        cursor: pointer;
    }
    .call-action-btn.decline { background-color: #d9534f; }
    .call-action-btn.accept { background-color: #5cb85c; }

    /* Active Call */
    #local-video {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 150px;
        border: 2px solid white;
        border-radius: 8px;
        z-index: 3001;
    }
    #remote-videos-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
        gap: 5px;
        padding: 5px;
    }
    .remote-video {
        background-color: #000;
        flex-grow: 1;
        object-fit: cover;
        max-width: 50%; /* Example for 2xN grid */
    }
    .active-call-ui {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        padding: 20px;
        z-index: 3002;
        background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
    }
    .peer-info {
        text-align: center;
        margin-bottom: 20px;
    }
    .call-controls {
        display: flex;
        gap: 20px;
    }
    .call-control-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        background-color: rgba(255, 255, 255, 0.2);
        color: white;
        font-size: 24px;
        cursor: pointer;
    }
    .call-control-btn.active {
        background-color: rgba(255, 255, 255, 0.4);
    }
    .call-control-btn.end-call {
        background-color: #d9534f;
    }
    .join-call-banner {
        padding: 10px 15px;
        background-color: #e6f7ff;
        border-bottom: 1px solid #91d5ff;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
    }
    .join-call-banner.hidden {
        display: none;
    }
    .contact-share-content {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        width: 90%;
        max-width: 400px;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
    }
    .contact-list {
        overflow-y: auto;
        flex-grow: 1;
    }
    .contact-item {
        display: flex;
        align-items: center;
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
    }
    .contact-item:hover {
        background-color: #f7f7f7;
    }
    .contact-item img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 15px;
    }
    .contact-card {
        padding: 10px 15px;
        background-color: #f0f2f5;
        border-radius: 8px;
        display: flex;
        align-items: center;
        gap: 15px;
        border: 1px solid #e0e0e0;
    }
    .contact-card img {
        width: 50px;
        height: 50px;
        border-radius: 50%;
    }
    .contact-card-info strong {
        display: block;
        font-size: 1.1em;
    }
    .contact-card-info a {
        font-size: 0.9em;
        text-decoration: none;
    }
    .location-card {
        padding: 10px 15px;
    }
    .location-card a {
        display: flex;
        align-items: center;
        gap: 10px;
        text-decoration: none;
        font-weight: bold;
    }
    emoji-picker {
        position: absolute;
        bottom: 60px; /* Position above the input bar */
        left: 10px;
        z-index: 1000;
    }
    emoji-picker.hidden {
        display: none;
    }
</style>
{% endblock %}

{% block chat_scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Emoji Picker Logic
    const emojiBtn = document.querySelector('.emoji-btn');
    const emojiPicker = document.querySelector('emoji-picker');
    const messageInput = document.querySelector('.message-input');

    emojiBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        emojiPicker.classList.toggle('hidden');
    });

    emojiPicker.addEventListener('emoji-click', event => {
        messageInput.value += event.detail.unicode;
    });

    // Hide picker when clicking outside
    document.addEventListener('click', function(event) {
        if (!emojiPicker.contains(event.target) && !emojiBtn.contains(event.target)) {
            emojiPicker.classList.add('hidden');
        }
    });

    // Auto-resize textarea
    const textarea = document.querySelector('.message-input');
    if (textarea) {
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
    }

    // Scroll to the bottom of the messages
    const messageArea = document.querySelector('.message-area');
    if (messageArea) {
        messageArea.scrollTop = messageArea.scrollHeight;
    }

    // Media menu toggle
    const mediaBtn = document.querySelector('.media-btn');
    const mediaMenu = document.getElementById('media-menu');
    const conversationPage = document.querySelector('.conversation-page');

    if (mediaBtn && mediaMenu) {
        mediaBtn.addEventListener('click', function(event) {
            event.stopPropagation();
            mediaMenu.classList.toggle('hidden');
        });

        document.addEventListener('click', function(event) {
            if (!mediaMenu.contains(event.target) && !mediaBtn.contains(event.target)) {
                mediaMenu.classList.add('hidden');
            }
        });
    }

    // Poll creation logic
    const pollBtn = document.getElementById('create-poll-btn');
    if (pollBtn) {
        pollBtn.addEventListener('click', function() {
            const question = prompt("Enter the poll question:");
            if (!question) return;

            let options = [];
            let option;
            while (options.length < 10 && (option = prompt(`Enter option ${options.length + 1} (or leave blank to finish):`))) {
                options.push(option);
            }

            if (options.length < 2) {
                alert("A poll requires at least two options.");
                return;
            }

            // Hide the media menu after gathering input
            if (mediaMenu) {
                mediaMenu.classList.add('hidden');
            }

            socket.emit('create_poll', {
                room_id: {{ chat_info.id|tojson }},
                question: question,
                options: options
            });
        });
    }

    // --- Refactored Upload Logic ---
    function uploadFile(file, fileName) {
        const formData = new FormData();
        formData.append('file', file, fileName);

        fetch('/chat/upload', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                alert('Upload failed: ' + data.error);
                return;
            }
            socket.emit('message', {
                room_id: {{ chat_info.id|tojson }},
                file_path: data.file_path,
                file_name: data.file_name
            });
        })
        .catch(error => {
            console.error('Upload error:', error);
            alert('An error occurred during upload.');
        });
    }

    function triggerFileUpload(accept) {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = accept;
        input.style.display = 'none';
        input.onchange = () => {
            if (input.files.length > 0) {
                uploadFile(input.files[0], input.files[0].name);
            }
            document.body.removeChild(input);
        };
        document.body.appendChild(input);
        input.click();
    }

    document.getElementById('media-gallery-btn')?.addEventListener('click', () => {
        triggerFileUpload('image/*,video/*');
        if (mediaMenu) mediaMenu.classList.add('hidden');
    });

    document.getElementById('media-document-btn')?.addEventListener('click', () => {
        triggerFileUpload('.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt');
        if (mediaMenu) mediaMenu.classList.add('hidden');
    });

    // --- Camera Feature Logic ---
    const cameraModal = document.getElementById('camera-modal');
    const cameraPreview = document.getElementById('camera-preview');
    const closeCameraBtn = document.getElementById('close-camera-btn');
    const capturePhotoBtn = document.getElementById('capture-photo-btn');
    const recordVideoBtn = document.getElementById('record-video-btn');
    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];

    async function startCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            cameraPreview.srcObject = stream;
            cameraModal.classList.remove('hidden');
        } catch (err) {
            console.error("Error accessing camera:", err);
            alert("Could not access the camera. Please check permissions.");
        }
    }

    function stopCamera() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        stream = null;
        cameraPreview.srcObject = null;
        cameraModal.classList.add('hidden');
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        recordVideoBtn.classList.remove('recording');
        recordVideoBtn.innerHTML = '<i class="fa-solid fa-video"></i>';

    }

    document.getElementById('media-camera-btn')?.addEventListener('click', () => {
        if (mediaMenu) mediaMenu.classList.add('hidden');
        startCamera();
    });

    closeCameraBtn.addEventListener('click', stopCamera);

    capturePhotoBtn.addEventListener('click', () => {
        const canvas = document.createElement('canvas');
        canvas.width = cameraPreview.videoWidth;
        canvas.height = cameraPreview.videoHeight;
        canvas.getContext('2d').drawImage(cameraPreview, 0, 0);
        canvas.toBlob(blob => {
            uploadFile(blob, `photo-${Date.now()}.jpg`);
            stopCamera();
        }, 'image/jpeg');
    });

    recordVideoBtn.addEventListener('click', () => {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
            // Start recording
            if (!stream) return;
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                uploadFile(blob, `video-${Date.now()}.webm`);
                stopCamera();
            };
            mediaRecorder.start();
            recordVideoBtn.classList.add('recording');
            recordVideoBtn.innerHTML = '<i class="fa-solid fa-stop"></i>';

        } else {
            // Stop recording
            mediaRecorder.stop();
        }
    });


    // --- Voice Note Logic ---
    const voiceRecordBtn = document.getElementById('media-voice-btn');
    const messageInputBar = document.querySelector('.message-input-bar');
    const voiceRecorderBar = document.getElementById('voice-recorder-bar');
    const cancelVoiceBtn = document.getElementById('cancel-voice-btn');
    const sendVoiceBtn = document.getElementById('send-voice-btn');
    const voiceTimer = document.getElementById('voice-timer');

    let voiceStream = null;
    let voiceRecorder = null;
    let voiceChunks = [];
    let timerInterval = null;

    function cleanupVoiceRecording() {
        if (voiceStream) {
            voiceStream.getTracks().forEach(track => track.stop());
        }
        if (timerInterval) {
            clearInterval(timerInterval);
        }
        voiceStream = null;
        voiceRecorder = null;
        voiceChunks = [];
        timerInterval = null;
        messageInputBar.classList.remove('hidden');
        voiceRecorderBar.classList.add('hidden');
    }

    voiceRecordBtn?.addEventListener('click', async () => {
        if (mediaMenu) mediaMenu.classList.add('hidden');

        try {
            voiceStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });

            messageInputBar.classList.add('hidden');
            voiceRecorderBar.classList.remove('hidden');

            voiceRecorder = new MediaRecorder(voiceStream, { mimeType: 'audio/webm' });
            voiceChunks = [];

            voiceRecorder.ondataavailable = event => {
                voiceChunks.push(event.data);
            };

            voiceRecorder.onstop = () => {
                if (voiceChunks.length > 0) {
                    const blob = new Blob(voiceChunks, { type: 'audio/webm' });
                    uploadFile(blob, `voice-note-${Date.now()}.webm`);
                }
                cleanupVoiceRecording();
            };

            voiceRecorder.start();
            let seconds = 0;
            timerInterval = setInterval(() => {
                seconds++;
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                voiceTimer.textContent = `${mins}:${secs}`;
            }, 1000);

        } catch (err) {
            console.error("Error accessing microphone:", err);
            alert("Could not access the microphone. Please check permissions.");
            cleanupVoiceRecording();
        }
    });

    sendVoiceBtn.addEventListener('click', () => {
        if (voiceRecorder && voiceRecorder.state === 'recording') {
            voiceRecorder.stop();
        }
    });

    cancelVoiceBtn.addEventListener('click', () => {
        if (voiceRecorder && voiceRecorder.state === 'recording') {
            voiceChunks = []; // Discard chunks
            voiceRecorder.stop();
        } else {
            cleanupVoiceRecording();
        }
    });


    // --- WebRTC & Call State Management ---
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const videoCallBtn = document.getElementById('video-call-btn');
    const incomingCallContainer = document.getElementById('incoming-call-container');
    const activeCallContainer = document.getElementById('active-call-container');
    const joinCallBanner = document.getElementById('join-call-banner');
    const joinCallBtn = document.getElementById('join-call-btn');

    // State variables
    let peerConnections = {}; // Use a dictionary for multiple connections {userId: pc}
    let localStream;
    let currentCallId = null;
    let callData = {}; // Generic call data store

    const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // --- Helper Functions ---
    async function getMedia(callType) {
        if (localStream) {
            // Ensure existing tracks are stopped before getting a new stream
            localStream.getTracks().forEach(track => track.stop());
        }
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: callType === 'video', audio: true });
            document.getElementById('local-video').srcObject = localStream;
        } catch (err) {
            console.error("Error getting user media:", err);
            alert("Could not access camera/microphone.");
            localStream = null; // Ensure stream is null on error
        }
    }

    function createPeerConnection(otherUserId, isOneToOne) {
        if (peerConnections[otherUserId]) {
            peerConnections[otherUserId].close();
        }

        const pc = new RTCPeerConnection(servers);
        peerConnections[otherUserId] = pc;

        pc.onicecandidate = event => {
            if (event.candidate) {
                const eventName = isOneToOne ? 'ice_candidate' : 'webrtc_ice_candidate';
                socket.emit(eventName, {
                    candidate: event.candidate,
                    to_user_id: otherUserId,
                    from_user_id: {{ current_user.id }},
                    room_id: {{ chat_info.id|tojson }}
                });
            }
        };

        pc.ontrack = event => {
            const container = document.getElementById('remote-videos-container');
            let video = document.getElementById(`video-${otherUserId}`);
            if (!video) {
                video = document.createElement('video');
                video.id = `video-${otherUserId}`;
                video.className = 'remote-video';
                video.autoplay = true;
                video.playsInline = true;
                container.appendChild(video);
            }
            video.srcObject = event.streams[0];
        };

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        return pc;
    }

    function setupActiveCallUI(userInfo, callType) {
        document.getElementById('active-caller-name').innerText = userInfo.name;
        const avatarContainer = document.getElementById('voice-call-avatar-container');
        const remoteVideoContainer = document.getElementById('remote-videos-container');
        const toggleCameraBtn = document.getElementById('toggle-camera-btn');

        if (callType === 'voice') {
            document.getElementById('active-call-avatar').src = `/static/profile_pics/${userInfo.profile_pic}`;
            avatarContainer.classList.remove('hidden');
            remoteVideoContainer.classList.add('hidden');
            toggleCameraBtn.classList.add('hidden');
        } else {
            avatarContainer.classList.add('hidden');
            remoteVideoContainer.classList.remove('hidden');
            toggleCameraBtn.classList.remove('hidden');
        }
        activeCallContainer.classList.remove('hidden');
    }

    function endCall(reason = 'ended') {
        Object.values(peerConnections).forEach(pc => pc.close());
        peerConnections = {};

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        activeCallContainer.classList.add('hidden');
        incomingCallContainer.classList.add('hidden');
        joinCallBanner.classList.add('hidden');

        if (currentCallId) {
            socket.emit('end_call', {
                call_id: currentCallId,
                room_id: {{ chat_info.id|tojson }},
                reason: reason
            });
        }
        currentCallId = null;
        callData = {};
    }

    // --- Call Initiation ---
    async function startCall(callType, calleeId) {
        await getMedia(callType);
        if (!localStream) return;

        callData = { isCaller: true, call_type: callType, callee_id: calleeId };
        setupActiveCallUI({ name: 'Calling...' }, callType);

        socket.emit('start_call', {
            room_id: {{ chat_info.id|tojson }},
            callee_id: calleeId,
            call_type: callType
        });
    }

    voiceCallBtn?.addEventListener('click', () => {
        const calleeId = voiceCallBtn.hasAttribute('data-callee-id') ? parseInt(voiceCallBtn.dataset.calleeId, 10) : undefined;
        startCall('voice', calleeId);
    });
    videoCallBtn?.addEventListener('click', () => {
        const calleeId = videoCallBtn.hasAttribute('data-callee-id') ? parseInt(videoCallBtn.dataset.calleeId, 10) : undefined;
        startCall('video', calleeId);
    });

    // --- One-to-One Call Handlers ---
    socket.on('call_started', async (data) => {
        if (callData.isCaller && callData.callee_id) {
            currentCallId = data.call_id;
            const pc = createPeerConnection(callData.callee_id, true);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('offer', { offer: offer, call_id: currentCallId, room_id: {{ chat_info.id|tojson }} });
        }
    });

    socket.on('incoming_call', (data) => {
        if (Object.keys(peerConnections).length > 0 || !incomingCallContainer.classList.contains('hidden')) return;
        if (data.callee_id === {{ current_user.id }}) {
            callData = { ...data, isCaller: false };
            currentCallId = data.call_id;
            document.getElementById('incoming-caller-name').innerText = data.caller_name;
            document.getElementById('incoming-call-type').innerText = `Incoming ${data.call_type} call...`;
            document.getElementById('incoming-caller-avatar').src = `/static/profile_pics/${data.caller_profile_pic}`;
            incomingCallContainer.classList.remove('hidden');
        }
    });

    socket.on('offer_received', (data) => {
        if (!callData.isCaller && callData.caller_id === data.caller_id) {
            callData.offer = data.offer;
        }
    });

    document.getElementById('accept-call-btn').addEventListener('click', async () => {
        if (!callData.offer) return;
        await getMedia(callData.call_type);
        if (!localStream) return;

        incomingCallContainer.classList.add('hidden');
        setupActiveCallUI({ name: callData.caller_name, profile_pic: callData.caller_profile_pic }, callData.call_type);

        const pc = createPeerConnection(callData.caller_id, true);
        await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        socket.emit('answer', { answer: answer, call_id: currentCallId, room_id: {{ chat_info.id|tojson }} });
    });

    socket.on('answer_received', async (data) => {
        const pc = peerConnections[data.callee_id];
        if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            setupActiveCallUI(data.callee_info, callData.call_type);
        }
    });

    socket.on('ice_candidate_received', (data) => {
        const pc = peerConnections[data.from_id];
        if (pc) {
            pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    });

    // --- Universal Call Controls & End ---
    document.getElementById('decline-call-btn').addEventListener('click', () => endCall('declined'));
    document.getElementById('end-active-call-btn').addEventListener('click', () => endCall('ended'));
    socket.on('call_ended', () => endCall());

    // --- Group Call Handlers ---
    socket.on('group_call_started', (data) => {
        // Show banner for users who didn't start the call
        if (Object.keys(peerConnections).length === 0) {
            currentCallId = data.call_id;
            joinCallBanner.classList.remove('hidden');
        }
    });

    joinCallBtn.addEventListener('click', async () => {
        joinCallBanner.classList.add('hidden');
        await getMedia('video'); // Assume group calls are video
        if (!localStream) return;

        setupActiveCallUI({ name: 'Group Call' }, 'video');
        socket.emit('join_group_call', { call_id: currentCallId });
    });

    socket.on('existing_participants', (data) => {
        data.participants.forEach(userId => {
            // For each existing user, create a PC and send them an offer
            const pc = createPeerConnection(userId, false);
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .then(() => {
                    socket.emit('webrtc_offer', {
                        to_user_id: userId,
                        from_user_id: {{ current_user.id }},
                        offer: pc.localDescription
                    });
                })
                .catch(err => console.error("Offer creation failed", err));
        });
    });

    socket.on('new_participant', (data) => {
        // A new user has joined. We will receive an offer from them.
        // We just need to create a PC for them in preparation.
        createPeerConnection(data.user_id, false);
    });

    socket.on('webrtc_offer_received', async (data) => {
        const fromUserId = data.from_user_id;
        const pc = createPeerConnection(fromUserId, false);
        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('webrtc_answer', {
            to_user_id: fromUserId,
            from_user_id: {{ current_user.id }},
            answer: pc.localDescription
        });
    });

    socket.on('webrtc_answer_received', async (data) => {
        const pc = peerConnections[data.from_user_id];
        if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
    });

    socket.on('webrtc_ice_candidate_received', (data) => {
        const pc = peerConnections[data.from_user_id];
        if (pc) {
            pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    });

    socket.on('participant_left', (data) => {
        const userId = data.user_id;
        if (peerConnections[userId]) {
            peerConnections[userId].close();
            delete peerConnections[userId];
        }
        const videoElement = document.getElementById(`video-${userId}`);
        if (videoElement) {
            videoElement.remove();
        }
    });


    // --- Location Sharing Logic ---
    const locationBtn = document.getElementById('media-location-btn');
    locationBtn?.addEventListener('click', () => {
        if (mediaMenu) mediaMenu.classList.add('hidden');
        if (!navigator.geolocation) {
            return alert('Geolocation is not supported by your browser.');
        }

        navigator.geolocation.getCurrentPosition((position) => {
            const { latitude, longitude } = position.coords;
            socket.emit('send_location', {
                room_id: {{ chat_info.id|tojson }},
                latitude: latitude,
                longitude: longitude
            });
        }, () => {
            alert('Unable to retrieve your location.');
        });
    });

    // --- Contact Share Logic ---
    const contactShareBtn = document.getElementById('media-contact-btn');
    const contactShareModal = document.getElementById('contact-share-modal');
    const closeContactModalBtn = document.getElementById('close-contact-modal-btn');
    const contactList = document.getElementById('contact-list');

    async function openContactShareModal() {
        contactList.innerHTML = '<li>Loading...</li>'; // Show a loading state
        contactShareModal.classList.remove('hidden');

        try {
            const response = await fetch(`/chat/room/${ {{ chat_info.id|tojson }} }/users`);
            const users = await response.json();

            contactList.innerHTML = ''; // Clear loading state
            users.forEach(user => {
                // Don't list the current user
                if (user.id === {{ current_user.id }}) return;

                const item = document.createElement('div');
                item.className = 'contact-item';
                item.dataset.userId = user.id;
                item.innerHTML = `
                    <img src="/static/profile_pics/${user.profile_pic || 'default.jpg'}" alt="${user.name}">
                    <span>${user.name}</span>
                `;
                item.addEventListener('click', () => {
                    socket.emit('send_contact', {
                        room_id: {{ chat_info.id|tojson }},
                        shared_user_id: user.id
                    });
                    contactShareModal.classList.add('hidden');
                });
                contactList.appendChild(item);
            });
        } catch (error) {
            console.error('Failed to fetch users:', error);
            contactList.innerHTML = '<li>Failed to load contacts.</li>';
        }
    }

    contactShareBtn.addEventListener('click', () => {
        if (mediaMenu) mediaMenu.classList.add('hidden');
        openContactShareModal();
    });
    closeContactModalBtn.addEventListener('click', () => {
        contactShareModal.classList.add('hidden');
    });


    // Placeholder logic for remaining buttons
    const placeholderBtns = [];
    placeholderBtns.forEach(btnInfo => {
        const btn = document.getElementById(btnInfo.id);
        if (btn) {
            btn.addEventListener('click', () => {
                alert(btnInfo.name + ' functionality is not yet implemented.');
                if (mediaMenu) {
                    mediaMenu.classList.add('hidden');
                }
            });
        }
    });

    socket.on('message', function(data) {
        if (data.room_id !== {{ chat_info.id|tojson }}) {
            return; // Ignore messages for other rooms
        }

        const messageArea = document.querySelector('.message-area');
        const messageBubbleWrapper = document.createElement('div');
        messageBubbleWrapper.classList.add('message-bubble-wrapper');
        if (data.user_id === {{ current_user_id }}) {
            messageBubbleWrapper.classList.add('sender');
        } else {
            messageBubbleWrapper.classList.add('receiver');
        }

        let fileHtml = '';
        if (data.file_path) {
            const fileName = data.file_name.toLowerCase();
            if (fileName.match(/\.(png|jpg|jpeg|gif|webp)$/)) {
                fileHtml = `<img src="/static/${data.file_path}" alt="${data.file_name}" class="message-image">`;
            } else if (fileName.match(/\.(mp4|webm|ogg)$/) && fileName.includes('video')) {
                fileHtml = `<video src="/static/${data.file_path}" controls class="message-video"></video>`;
            } else if (fileName.match(/\.(mp3|wav|webm|ogg)$/)) {
                fileHtml = `<audio src="/static/${data.file_path}" controls class="message-audio"></audio>`;
            } else {
                fileHtml = `<a href="/static/${data.file_path}" class="message-file" download>
                                <i class="fa-solid fa-file-arrow-down"></i> ${data.file_name}
                            </a>`;
            }
        }

        let contentHtml;
        try {
            const contentData = JSON.parse(data.content);
            if (contentData && contentData.type === 'contact') {
                contentHtml = `
                    <div class="contact-card">
                        <img src="/static/profile_pics/${contentData.profile_pic}" alt="${contentData.name}">
                        <div class="contact-card-info">
                            <strong>${contentData.name}</strong>
                            <a href="/user/${contentData.user_id}">View Profile</a>
                        </div>
                    </div>
                `;
            } else if (contentData && contentData.type === 'location') {
                contentHtml = `
                    <div class="location-card">
                        <a href="https://www.openstreetmap.org/?mlat=${contentData.latitude}&mlon=${contentData.longitude}#map=15/${contentData.latitude}/${contentData.longitude}" target="_blank">
                            <i class="fa-solid fa-map-location-dot"></i>
                            <span>View Location</span>
                        </a>
                    </div>
                `;
            } else {
                throw new Error("Not a contact card");
            }
        } catch (e) {
            contentHtml = data.content ? `<p class="message-content">${data.content}</p>` : '';
        }

        const messageBubble = `
            <div class="message-bubble">
                ${fileHtml}
                ${contentHtml}
                <span class="message-timestamp">${new Date(data.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
        `;
        messageBubbleWrapper.innerHTML = messageBubble;
        messageArea.appendChild(messageBubbleWrapper);
        messageArea.scrollTop = messageArea.scrollHeight;
    });

    socket.on('new_poll', function(data) {
        if (data.room_id !== {{ chat_info.id|tojson }}) {
            return;
        }

        const messageArea = document.querySelector('.message-area');
        const pollWrapper = document.createElement('div');
        pollWrapper.classList.add('message-bubble-wrapper');
        pollWrapper.classList.add(data.user_id === {{ current_user.id }} ? 'sender' : 'receiver');
        pollWrapper.setAttribute('id', `poll-${data.poll_id}`);

        let optionsHtml = '';
        data.options.forEach(option => {
            optionsHtml += `
                <div class="poll-option" data-option-id="${option.id}">
                    <span class="poll-option-text">${option.text}</span>
                    <span class="poll-option-votes">0 votes</span>
                </div>
            `;
        });

        const pollBubble = `
            <div class="message-bubble">
                <div class="poll-container">
                    <p class="poll-question">${data.question}</p>
                    <div class="poll-options">
                        ${optionsHtml}
                    </div>
                </div>
                <span class="message-timestamp">${new Date(data.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
        `;
        messageBubbleWrapper.innerHTML = messageBubble;
        messageArea.appendChild(messageBubbleWrapper);
        messageArea.scrollTop = messageArea.scrollHeight;
    });

    socket.on('new_poll', function(data) {
        if (data.room_id !== {{ chat_info.id|tojson }}) {
            return;
        }

        const messageArea = document.querySelector('.message-area');
        const pollWrapper = document.createElement('div');
        pollWrapper.classList.add('message-bubble-wrapper');
        pollWrapper.classList.add(data.user_id === {{ current_user_id }} ? 'sender' : 'receiver');
        pollWrapper.setAttribute('id', `poll-${data.poll_id}`);

        let optionsHtml = '';
        data.options.forEach(option => {
            optionsHtml += `
                <div class="poll-option" data-option-id="${option.id}">
                    <span class="poll-option-text">${option.text}</span>
                    <span class="poll-option-votes">0 votes</span>
                </div>
            `;
        });

        const pollBubble = `
            <div class="message-bubble">
                <div class="poll-container">
                    <p class="poll-question">${data.question}</p>
                    <div class="poll-options">
                        ${optionsHtml}
                    </div>
                </div>
                <span class="message-timestamp">${new Date(data.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            </div>
        `;

        pollWrapper.innerHTML = pollBubble;
        messageArea.appendChild(pollWrapper);
        messageArea.scrollTop = messageArea.scrollHeight;
    });

    // Handle poll voting by event delegation
    document.querySelector('.message-area').addEventListener('click', function(event) {
        const pollOption = event.target.closest('.poll-option');
        if (pollOption) {
            const optionId = pollOption.dataset.optionId;
            if (optionId) {
                socket.emit('poll_vote', { 'option_id': parseInt(optionId, 10) });
            }
        }
    });

    socket.on('poll_update', function(data) {
        if (data.room_id !== {{ chat_info.id|tojson }}) {
            return;
        }

        const pollElem = document.getElementById(`poll-${data.poll_id}`);
        if (!pollElem) return;

        let totalVotes = 0;
        data.options.forEach(opt => totalVotes += opt.votes);

        data.options.forEach(option => {
            const optionElem = pollElem.querySelector(`.poll-option[data-option-id="${option.id}"]`);
            if (optionElem) {
                const voteSpan = optionElem.querySelector('.poll-option-votes');
                const percentage = totalVotes > 0 ? ((option.votes / totalVotes) * 100).toFixed(0) : 0;
                voteSpan.textContent = `${option.votes} votes (${percentage}%)`;

                // Optional: Add a visual indicator for the vote percentage
                const progressBar = optionElem.querySelector('.poll-option-progress') || document.createElement('div');
                progressBar.className = 'poll-option-progress';
                progressBar.style.width = `${percentage}%`;
                if (!optionElem.querySelector('.poll-option-progress')) {
                    optionElem.insertAdjacentElement('afterbegin', progressBar);
                }
            }
        });
    });
});
</script>
{% endblock %}
